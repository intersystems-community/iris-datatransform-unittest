Include UnitTestHelper

/// Data Transform Test Case 
Class UnitTestHelper.DataTransformTestCase Extends %UnitTest.TestCase
{

/// Directory containing data-transform tests
/// Sub-classes *MUST* define this config parameter
Parameter TestDirectory;

/// Directory containing look-up table data that must be loaded BEFORE running tests
Parameter BeforeLookUpDirectory;

/// Directory containing look-up table data that must be loaded AFTER running tests
Parameter AfterLookUpDirectory;

/// LookUp table names (comma separated list) that will be 
/// 1) imported BEFORE running the test. LookUp table file must be in <BeforeLookUpDirectory>/<LookUpTable>.xml
/// 2) restored AFTER running the test. LookUp table file must be in <AfterLookUpDirectory>/<LookUpTable>.xml
Parameter LookUpTables;

/// Property used during test execution to store the actual path to test files
Property FilePath As %String(MAXLEN = "");

/// Initilization before running tests
Method OnBeforeAllTests() As %Status
{
	set ret = $$$OK
	try {
		set ..FilePath=##class(%File).NormalizeDirectory("", ..#TestDirectory)
		if ..FilePath="" $$$ThrowStatus($$$ERROR($$$GeneralError, ..#TestDirectory_" TestDirectory incorrect"))

		// import lookup tables BEFORE running tests
		if ..#LookUpTables'="" $$$ThrowOnError(..ImportLookUp($listfromstring(..#LookUpTables)))
		
	} catch ex {
		set ret = ex.AsStatus()
	}
	quit ret
}

/// Data Transform Test
/// 
/// Sub-directories in <TestDirectory>/ must be names of the data transform class you want to test.
/// 
/// Within <TestDirectory>/<DataTransformClassName>/ the files are processed as follows:
/// - <TestName>.in.txt: 
///     input object that will be passed to data transform
/// - [<TestName>.nfo.txt]: 
///     optional. file containing a short description of the test
/// 	this line will be shown in the unittest report
/// - <TestName>.out.txt: 
///     output object that is *expected* to be generated by the data transform for the given input
/// - <TestName>.gen.txt: 
///     automatically generated file
/// 	actual output generated by the data transform for the given input
Method TestDataTransforms()
{
	// path to <TestDirectory>/
	set dtdir = ..FilePath
	
	set rs = ##class(%ResultSet).%New("%File:FileSet")
 	set sc = rs.Execute(dtdir,"*","","1")
 	if '##class(%File).DirectoryExists(dtdir) {
	 	do $$$LogMessage("there are no tests for data transformations")
 	}
 	
 	// each sub-directory in <TestDirectory>/ 
 	// is a data transform classname to test
	while (rs.Next()) {
		set dirpath = rs.Data("Name")
		set dirname = ##class(%File).GetFilename(dirpath)
		if '##class(%File).DirectoryExists(dirpath) continue
		
		// *.in.txt  => input
		// *.out.txt => expected output
		// *.gen.txt => actual output
		// *.nfo.txt => info about test
		set rsdir = ##class(%ResultSet).%New("%File:FileSet")
 		set sc = rsdir.Execute(dirpath, "*.in.txt")
 		do $$$AssertStatusOK(sc, dirname)
		while (rsdir.Next()) {
			try {
				// test files: full path
				set inputpath = rsdir.Data("Name")
				set outputpath = $replace(inputpath, ".in.txt", ".out.txt")
				set genpath = $replace(inputpath, ".in.txt", ".gen.txt")
				set nfopath = $replace(inputpath, ".in.txt", ".nfo.txt")
				
				// test files: filenames
				set inputname = ##class(%File).GetFilename(inputpath)
				set outputname = ##class(%File).GetFilename(outputpath)
				set genname = ##class(%File).GetFilename(genpath)
				
				// test name
				set testname = $replace(inputname, ".in.txt", "")
				
				// check that required files are present
				if '##class(%File).Exists(outputpath) {
					$$$ThrowStatus($$$ERROR($$$GeneralError, testname_": no .out.txt file"))
				}
				
				// display info in *.nfo.txt (if exists)
				set nfo=""
				if ##class(%File).Exists(nfopath) {
					set nfoFile = ##class(%Stream.FileCharacter).%New()
					set nfoFile.Filename = nfopath
					set nfo=nfoFile.Read()
				}
				
				// get data transform source and target types
				set sourceType = $classmethod(dirname, "GetSourceType")
				set targetType = $classmethod(dirname, "GetTargetType")
				
				// import input object (in.txt)
				$$$ThrowOnError(..ImportFileUsingClassname(inputpath, sourceType, .input))
				
				// execute data transform
				set genobj = $classmethod(targetType, "%New")
				$$$ThrowOnError($classmethod(dirname, "Transform", input, .genobj))
				
				#if $$$UnitTestHL7Enabled
				// if HL7, ignore MSH:7 (timestamp)
				if targetType="EnsLib.HL7.Message" {
					$$$ThrowOnError(..ImportFileUsingClassname(outputpath, targetType, .output))
					set output.DocType = genobj.DocType
					set ts = output.GetValueAt("MSH:7")
					do genobj.SetValueAt(ts, "MSH:7")
					do genobj.%Save()
				}
				#endif
				
				// get actual output object generated by data transform
				$$$ThrowOnError(..ExportObject(genobj, genpath))
				
				// compare expected output Vs. actual output
				set compare = ##class(%File).Compare(outputpath, genpath)
				do $$$AssertEquals(1, compare, testname_$case(nfo, "":"", :": "_nfo))
				
				// if expected Vs. actual are equal, delete .gen.txt file (actual output)
				if compare {
					do ##class(%File).Delete(genpath)
				}
			} catch ex {
				// exception while running data transformation tests
				// log the failure, and continue to next test
				do $$$AssertFailure(ex.DisplayString())
			}
		}
		
	}
}

/// Import file as an object (considering its class)
/// - path: path to the file that must be loaded
/// - classname: object class
/// - obj: imported object
ClassMethod ImportFileUsingClassname(path As %String, classname As %String, Output obj) As %Status
{
	set ret = $$$OK
	try {
		set name = ##class(%File).GetFilename(path)
		#if $$$UnitTestHL7Enabled
		if classname="EnsLib.HL7.Segment" {
			set content = ##class(%Stream.FileCharacter).%New()
			set content.Filename = path
			set obj = ##class(EnsLib.HL7.Segment).ImportFromString(content.Read(), .sc)
			$$$ThrowOnError(sc)
		} 
		elseif classname="EnsLib.HL7.Message" {
			set obj = ##class(EnsLib.HL7.Message).ImportFromFile(path, .sc)
			$$$ThrowOnError(sc)
		}
		else {
		#endif
			set content = ##class(%Stream.FileCharacter).%New()
			set content.Filename = path
			
			set reader = ##class(%XML.Reader).%New()
	 		do reader.OpenStream(content)
	 
	 		// get root element to import XML
	 		set xmlroot = $parameter(classname, "XMLNAME")
	 		if xmlroot="" {
		 		set xmlroot = $piece(classname,".",$length(classname,"."))
	 		}
	 		if xmlroot="" $$$ThrowStatus($$$ERROR($$$GeneralError, "xmlroot empty"))
	 		
	 		do reader.Correlate(xmlroot, classname)
	 		do reader.Next(.obj,.sc)
	 		if $$$ISERR(sc) $$$ThrowStatus(sc)
		#if $$$UnitTestHL7Enabled
		}
		#endif
		if '$isobject(obj) $$$ThrowStatus($$$ERROR($$$GeneralError, "error while importing object"))
	} catch ex {
		set ret = ex.AsStatus()
	}
	quit ret
}

/// Export an object to a file
/// - obj: objeto to export
/// - path: path to the file where object will be exported.
ClassMethod ExportObject(ByRef obj, path As %String) As %Status
{
	set ret = $$$OK
	try {
		set classname = $classname(obj)
		set name = ##class(%File).GetFilename(path)
		#if $$$UnitTestHL7Enabled
		if classname="EnsLib.HL7.Segment" {
			set st = $method(obj, "OutputToString")
			set file = ##class(%Stream.FileCharacter).%New()
			set file.Filename = path
			do file.Write(st)
			$$$ThrowOnError(file.%Save())
		} 
		elseif classname="EnsLib.HL7.Message" {
			set sc = $method(obj, "OutputToFile", path, 1)
			$$$ThrowOnError(sc)
		}
		else {
		#endif
			set writer = ##class(%XML.Writer).%New()
			set writer.Indent=1
			set writer.NoXMLDeclaration=1
			$$$ThrowOnError(writer.OutputToFile(path))
			$$$ThrowOnError(writer.RootObject(obj))
		#if $$$UnitTestHL7Enabled
		}
		#endif
	} catch ex {
		set ret = ex.AsStatus()
	}
	quit ret
}

/// Import LookUp tables required for data transform tests
Method ImportLookUp(fileList As %List) As %Status
{
	set ret = $$$OK
	try {
		if ..#BeforeLookUpDirectory'="" {
			set dir = ##class(%File).NormalizeDirectory("", ..#BeforeLookUpDirectory)
			if dir'="" $$$ThrowOnError(..ImportFile(dir, fileList))
		}
	} catch ex {
		set ret = ex.AsStatus()
	}
	quit ret
}

/// Restore LookUp tables after running tests
Method RestoreLookup(fileList As %List) As %Status
{
	set ret = $$$OK
	try {
		// restore lookup tables
		if ..#AfterLookUpDirectory'="" {
			set dir = ##class(%File).NormalizeDirectory("", ..#AfterLookUpDirectory)
			if dir'="" $$$ThrowOnError(..ImportFile(dir, fileList))
		}
	} catch ex {
		set ret = ex.AsStatus()
	}
	quit ret
}

/// Import a list of files from a given base path. Useful to import required files for the tests.
ClassMethod ImportFile(pathBase As %String, fileList As %List) As %Status
{
	set ret = $$$OK
	try {
		for i=1:1:$listlength(fileList) {
			do $system.OBJ.Load(pathBase_$listget(fileList, i))
		}
	} catch ex {
		set ret = ex.AsStatus()
	}
	quit ret
}

/// After running all tests
Method OnAfterAllTests() As %Status
{
 	set ret = $$$OK
	try {
		// restore lookup tables
		if ..#LookUpTables'="" $$$ThrowOnError(..RestoreLookup($listfromstring(..#LookUpTables)))
		
	} catch ex {
		set ret = ex.AsStatus()
	}
	quit ret
}

/// Run Test Case
/// - pTestCase: testcase to run. if no testcase specified, all testcases will be tested.
/// - pDebug: test will be run in debug mode or not.
ClassMethod Run(pWorkSpace As %String = "", pTestCase As %String = "", pDebug As %Boolean = 0) As %Status
{
	set ret = $$$OK
	try {
		set testRoot = ##class(%File).NormalizeDirectory(pWorkSpace)
		set ^UnitTestRoot = testRoot
		
		set flags = "/nodelete"
		if pDebug set flags=flags_"/debug"
		
		do ##class(%UnitTest.Manager).RunTest(pTestCase, flags)

	} catch ex {
		set ret = ex.AsStatus()
		do $system.Status.DisplayError(ret)
	}
	quit ret
}

}
